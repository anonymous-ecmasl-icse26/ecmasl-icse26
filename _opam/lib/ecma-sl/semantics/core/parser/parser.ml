
(* This generated code requires the following version of MenhirLib: *)

let () =
  MenhirLib.StaticVersion.require_20240715

module MenhirBasics = struct
  
  exception Error
  
  let _eRR =
    fun _s ->
      raise Error
  
  type token = 
    | WHILE
    | TYPEOF
    | TIMES
    | TILDE
    | SYMBOL of (
# 17 "src/semantics/core/parser/parser.mly"
       (string)
# 24 "src/semantics/core/parser/parser.ml"
  )
    | SWITCH
    | STRING_TO_INT
    | STRING_TO_FLOAT
    | STRING of (
# 15 "src/semantics/core/parser/parser.mly"
       (string)
# 32 "src/semantics/core/parser/parser.ml"
  )
    | SHIFT_RIGHT_LOGICAL
    | SHIFT_RIGHT
    | SHIFT_LEFT
    | SEMICOLON
    | RPAREN
    | RETURN
    | RBRACK
    | RBRACE
    | QUESTION
    | PRINT
    | POW
    | PLUS
    | PIPE
    | OBJECT_TO_LIST
    | OBJECT_MEM
    | OBJECT_FIELDS
    | NULL
    | NE
    | MODULO
    | MINUS
    | LT
    | LPAREN
    | LOR
    | LIST_TAIL
    | LIST_HEAD
    | LE
    | LBRACK
    | LBRACE
    | LAND
    | INT_TO_STRING
    | INT_TO_FLOAT
    | INT of (
# 13 "src/semantics/core/parser/parser.mly"
       (int)
# 68 "src/semantics/core/parser/parser.ml"
  )
    | IF
    | ID of (
# 18 "src/semantics/core/parser/parser.mly"
       (string)
# 74 "src/semantics/core/parser/parser.ml"
  )
    | HASH
    | GT
    | GE
    | FUNCTION
    | FLOAT_TO_STRING
    | FLOAT_TO_INT
    | FLOAT of (
# 14 "src/semantics/core/parser/parser.mly"
       (float)
# 85 "src/semantics/core/parser/parser.ml"
  )
    | FAIL
    | EXTERN
    | EXCLAMATION
    | EQ
    | EOF
    | ELSE
    | DIVIDE
    | DELETE
    | DEFEQ
    | DEFAULT
    | COMMA
    | COLON
    | CASE
    | CARET
    | BOOLEAN of (
# 16 "src/semantics/core/parser/parser.mly"
       (bool)
# 104 "src/semantics/core/parser/parser.ml"
  )
    | ATSIGN
    | ASSERT
    | AMPERSAND
  
end

include MenhirBasics

# 5 "src/semantics/core/parser/parser.mly"
  
  open EslSyntax
  open EslSyntax.Source
  open Parsing_utils

# 120 "src/semantics/core/parser/parser.ml"

module Tables = struct
  
  include MenhirBasics
  
  let token2terminal : token -> int =
    fun _tok ->
      match _tok with
      | AMPERSAND ->
          68
      | ASSERT ->
          67
      | ATSIGN ->
          66
      | BOOLEAN _ ->
          65
      | CARET ->
          64
      | CASE ->
          63
      | COLON ->
          62
      | COMMA ->
          61
      | DEFAULT ->
          60
      | DEFEQ ->
          59
      | DELETE ->
          58
      | DIVIDE ->
          57
      | ELSE ->
          56
      | EOF ->
          55
      | EQ ->
          54
      | EXCLAMATION ->
          53
      | EXTERN ->
          52
      | FAIL ->
          51
      | FLOAT _ ->
          50
      | FLOAT_TO_INT ->
          49
      | FLOAT_TO_STRING ->
          48
      | FUNCTION ->
          47
      | GE ->
          46
      | GT ->
          45
      | HASH ->
          44
      | ID _ ->
          43
      | IF ->
          42
      | INT _ ->
          41
      | INT_TO_FLOAT ->
          40
      | INT_TO_STRING ->
          39
      | LAND ->
          38
      | LBRACE ->
          37
      | LBRACK ->
          36
      | LE ->
          35
      | LIST_HEAD ->
          34
      | LIST_TAIL ->
          33
      | LOR ->
          32
      | LPAREN ->
          31
      | LT ->
          30
      | MINUS ->
          29
      | MODULO ->
          28
      | NE ->
          27
      | NULL ->
          26
      | OBJECT_FIELDS ->
          25
      | OBJECT_MEM ->
          24
      | OBJECT_TO_LIST ->
          23
      | PIPE ->
          22
      | PLUS ->
          21
      | POW ->
          20
      | PRINT ->
          19
      | QUESTION ->
          18
      | RBRACE ->
          17
      | RBRACK ->
          16
      | RETURN ->
          15
      | RPAREN ->
          14
      | SEMICOLON ->
          13
      | SHIFT_LEFT ->
          12
      | SHIFT_RIGHT ->
          11
      | SHIFT_RIGHT_LOGICAL ->
          10
      | STRING _ ->
          9
      | STRING_TO_FLOAT ->
          8
      | STRING_TO_INT ->
          7
      | SWITCH ->
          6
      | SYMBOL _ ->
          5
      | TILDE ->
          4
      | TIMES ->
          3
      | TYPEOF ->
          2
      | WHILE ->
          1
  
  and error_terminal =
    0
  
  and token2value : token -> Obj.t =
    fun _tok ->
      match _tok with
      | AMPERSAND ->
          Obj.repr ()
      | ASSERT ->
          Obj.repr ()
      | ATSIGN ->
          Obj.repr ()
      | BOOLEAN _v ->
          Obj.repr _v
      | CARET ->
          Obj.repr ()
      | CASE ->
          Obj.repr ()
      | COLON ->
          Obj.repr ()
      | COMMA ->
          Obj.repr ()
      | DEFAULT ->
          Obj.repr ()
      | DEFEQ ->
          Obj.repr ()
      | DELETE ->
          Obj.repr ()
      | DIVIDE ->
          Obj.repr ()
      | ELSE ->
          Obj.repr ()
      | EOF ->
          Obj.repr ()
      | EQ ->
          Obj.repr ()
      | EXCLAMATION ->
          Obj.repr ()
      | EXTERN ->
          Obj.repr ()
      | FAIL ->
          Obj.repr ()
      | FLOAT _v ->
          Obj.repr _v
      | FLOAT_TO_INT ->
          Obj.repr ()
      | FLOAT_TO_STRING ->
          Obj.repr ()
      | FUNCTION ->
          Obj.repr ()
      | GE ->
          Obj.repr ()
      | GT ->
          Obj.repr ()
      | HASH ->
          Obj.repr ()
      | ID _v ->
          Obj.repr _v
      | IF ->
          Obj.repr ()
      | INT _v ->
          Obj.repr _v
      | INT_TO_FLOAT ->
          Obj.repr ()
      | INT_TO_STRING ->
          Obj.repr ()
      | LAND ->
          Obj.repr ()
      | LBRACE ->
          Obj.repr ()
      | LBRACK ->
          Obj.repr ()
      | LE ->
          Obj.repr ()
      | LIST_HEAD ->
          Obj.repr ()
      | LIST_TAIL ->
          Obj.repr ()
      | LOR ->
          Obj.repr ()
      | LPAREN ->
          Obj.repr ()
      | LT ->
          Obj.repr ()
      | MINUS ->
          Obj.repr ()
      | MODULO ->
          Obj.repr ()
      | NE ->
          Obj.repr ()
      | NULL ->
          Obj.repr ()
      | OBJECT_FIELDS ->
          Obj.repr ()
      | OBJECT_MEM ->
          Obj.repr ()
      | OBJECT_TO_LIST ->
          Obj.repr ()
      | PIPE ->
          Obj.repr ()
      | PLUS ->
          Obj.repr ()
      | POW ->
          Obj.repr ()
      | PRINT ->
          Obj.repr ()
      | QUESTION ->
          Obj.repr ()
      | RBRACE ->
          Obj.repr ()
      | RBRACK ->
          Obj.repr ()
      | RETURN ->
          Obj.repr ()
      | RPAREN ->
          Obj.repr ()
      | SEMICOLON ->
          Obj.repr ()
      | SHIFT_LEFT ->
          Obj.repr ()
      | SHIFT_RIGHT ->
          Obj.repr ()
      | SHIFT_RIGHT_LOGICAL ->
          Obj.repr ()
      | STRING _v ->
          Obj.repr _v
      | STRING_TO_FLOAT ->
          Obj.repr ()
      | STRING_TO_INT ->
          Obj.repr ()
      | SWITCH ->
          Obj.repr ()
      | SYMBOL _v ->
          Obj.repr _v
      | TILDE ->
          Obj.repr ()
      | TIMES ->
          Obj.repr ()
      | TYPEOF ->
          Obj.repr ()
      | WHILE ->
          Obj.repr ()
  
  and default_reduction =
    (8, "\000\000\000o\000\000mp\000\000\000\000\000\000\000\000kq\000\000l\000n\019j\018\020(\021./,-\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\007\000\000Q\b\000G)*\000\017&10'+\000\t\001\000\000\025\000\000!\000\022\000\000S\000\000\000\000\000\024\000\026\000\000\000\000\000\000^\000\028\000\000\000_K\000O\000\014\000\000\000\000\000\000\000\000N\000\000\000\000\000\000\000\000\029i\000\000Z\005\\]\000\000\000\000\000\000\000c\000\000b\000\000\000ga\000\000\000\000Y[X\000\000W%\000\006\000\023\000\n\002\000#\000\011L\000\000U\003\000\000\012\004")
  
  and error =
    (69, "-\192\000%m\208\228\000An\000\001+n\135 \002\011p\000\t[t9\000\016\000\000\000\000\000\000\000\000\002\220\000\002V\221\014@\004\022\224\000\018\182\232r\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000-\192\000%m\208\228\000An\000\001+n\135 \002\011p\000\t[t9\000\016[\128\000J\219\161\200\000\130\220\b\002V\221\014@\004\022\224\000\018\182\232r\000 \183\000\000\149\183C\144\001\005\184\000\004\173\186\028\128\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011p\000\t[t9\000\016[\128\000J\219\161\200\000\128\000\000\000\000\000\000\000\000\022\224\000\018\182\232r\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\195p\244\1440\018\004Kp\000\t[t9\000\016 }\221?4\012\006\141\018\220\000\002V\221\014@\004\b\028\023\015I\003\001!D\183\000\000\149\183C\144\001\002\007\221\211\243@\192h\209-\192\000%m\208\228\000@\129\247t\252\2080\0264Kp\000\t[t9\000\016 }\221?4\012\006\141\018\220\000\002V\221\014@\004\b\031wO\205\003\001\163D\183\000\000\149\183C\144\001\002\007\221\211\243@\192h\209-\192\000%m\208\228\000@\129\247t\252\2080\0264Kp\000\t[t9\000\016 }\221?4\012\006\141\018\220\000\002V\221\014@\004\b\031wO\205\003\001\163D\183\000\000\149\183C\144\001\002\007\221\211\243@\192h\209-\192\000%m\208\228\000@\129\247t\252\2080\0264Kp\000\t[t9\000\016 }\221?4\012\006\141\018\220\000\002V\221\014@\004\b\031wO\205\003\001\163D\183\000\000\149\183C\144\001\002\007\221\211\243@\192h\209-\192\000%m\208\228\000@\129\247t\252\2080\0264Kp\000\t[t9\000\016 }\221?4\012\006\141\018\220\000\002V\221\014@\004\b\031wO\205\003\001\163D\183\000\000\149\183C\144\001\002\007\221\211\243@\192h\209-\192\000%m\208\228\000@\129\247t\252\2080\0264Kp\000\t[t9\000\016 }\221?4\012\006\141\018\220\000\002V\221\014@\004\b\031wO\205\003\001\163D\000\000\000\000\000\000\000\000\128\000\000\000 \000\000\000\000-\194\000%m\208\228\000@\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\003\170\225\233 `$H\150\224\000\018\182\232r\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\003\162\225\233 `$\b\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 p\\=$\012\006\129\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\128\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\016\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\027\240T\t[~=\b\020\000\000\000\002\000\000\000\000\002\220\000\002V\221\014@\004\b\029\023\015I\003\001 D\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\128\000\000\000\000\018\000D\000\002\000\004\002\000\004\000\000\000\000\000\000\000\001\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\t\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\002\000\000\000\000\000\000\000\000\004\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001n\"\001+n\135(\002\000\000\000\000\000\000\000\000\000 x\220=$\012\006\129\018\220\000\002V\221\014@\004\b\0307\015I\003\001\160E\191\005@\149\183\227\208\129@\000\000\000 \000\000\000\000\000\000\000\000\004\000\000\000\000\000\"\000\000\000\000\012\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\001\003\134\225\233\160`%\b\183\224\136\018\182\252z\016(\183\000\000\149\183C\144\001\002\007\141\195\210@\192h\017-\192\000%m\208\228\000@\129\193p\244\2080\018\004Kp\000\t[t9\000\016 q\\=$\012\004\129\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\183\000\000\149\183C\144\001\002\007\141\195\210@\192h\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\022\224\000\178\182\232v\000 \183\000\000\149\183C\144\001\002\007\141\195\210@\192h\017-\192\000%m\208\228\000@\129\227p\244\1440\026\004Kp\016\t[t9\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\002\007\141\211\243@\192h\017-\192\000%m\208\228\000@\129\227p\244\1440\026\004@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\003\130\225\233\160`$\b\128\000\000\000\000\000\000\b\000\183\000\000\149\183C\144\001\002\007\141\195\210@\192h\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\128\000\000\000\000\000\006\252\017\002V\223\143B\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\195p\244\2080\018\004@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\002\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\r\248\"\004\173\191\030\132\n\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")
  
  and start =
    4
  
  and action =
    ((16, "\n\182\n\182\n\182\000\000\n\182\n\182\000\000\000\000\n\182\n\182\n\182\n\182\n\182\n\182\n\182\n\182\000\000\000\000\n\182\n\182\000\000\n\182\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\242\n\182\000r\n\182\011\244\n\182\000\234\n\182\001b\n\182\001\218\n\182\002R\n\182\002\202\n\182\003B\n\182\003\186\n\182\0042\n\182\004\170\n\182\005\"\n\182\005\154\n\182\006\018\n\182\006\138\n\182\007\002\n\182\007z\n\182\007\242\n\182\bj\n\182\b\226\n\182\tZ\n\182\t\210\000q\000\023\014\144\000\000\000\016\000\000\011~\n\182\000\000\000\000\000\016\000\000\000\000\000\000\nJ\000\000\000\000\000\000\000\000\000\000\000\000\011~\000\000\000\000\0005\000#\000\000\000\t\000\025\000\000\000(\000\000\000\011\000#\000\000\000\000\000\003\000\026\n\182\011\244\000\000\000\000\000\000\000\026\000\016\000\011\000\003\000!\000\000\000\000\000\011\000\000\000\004\000\023\000\000\000\000\000\000\000T\000\000\n\182\000\000\011\244\n\182\0122\000\003\000\026\000\000\000\005\000\000\000\000\012p\000\003\n\182\012\230\n\182\nJ\n\182\nJ\000\000\000\000\n\182\r$\000\000\000\000\000\000\000\000\000\004\011\030\n\182\rb\n\182\r\160\014\144\000\000\000#\000\023\000\000\nJ\n\182\r\222\000\000\000\000\nJ\000\b\n\182\014\028\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000n\000\000\014\242\000\000\000*\000\000\000\000\0005\000\000\0002\000\000\000\000\000\020\0005\000\000\000\000\000\003\0006\000\000\000\000"), (16, "\001\206\000\006\000}\000\n\000\014\001\230\000\018\000\022\000\026\001E\001>\0011\000i\002\242\002&\0011\000\141\001U\0022\001%\001B\001\158\001N\0032\001f\000\030\001\162\001\170\000\"\000\133\000&\001\162\000*\000.\001\182\0002\002:\001\202\000:\000>\000B\002>\002R\002V\001\210\001\238\001\250\000J\000N\000R\002Z\002\018\000V\0011\002J\000i\001\190\002b\001\242\002\"\000\205\002\150\002\014\002\218\000Z\001M\002z\000\205\000\205\000\205\000\205\000\205\003\002\000\205\000\205\000\146\003\019\000\162\000\205\000\205\003'\000\205\003G\000\000\000\205\000\205\000\205\000\205\000\205\000\205\000\000\000\000\000\205\000\205\000\000\000\205\000\000\000\000\000\000\000\000\000\000\000\000\000\205\000\205\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\205\000\205\000\000\000\205\000\000\000\000\000\000\000\205\000\205\000\138\000\205\000\000\000\000\000\000\000\205\000\000\000\241\000\241\000\241\000\241\000\241\000\000\000\241\000\241\000\146\000\000\000\162\000\170\000\241\000\000\000\241\000\000\000\000\000\241\000\178\000\194\000\241\000\241\000\241\000\000\000\000\000\241\000\241\000\000\000\241\000\000\000\000\000\000\000\000\000\000\000\000\000\241\000\241\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\241\000\241\000\000\000\186\000\000\000\000\000\000\000\241\000\241\000\217\000\241\000\000\000\000\000\000\000\241\000\000\000\217\000\217\000\217\000\217\000\217\000\000\000\217\000\217\000\217\000\000\000\162\000\217\000\217\000\000\000\217\000\000\000\000\000\217\000\217\000\217\000\217\000\217\000\217\000\000\000\000\000\217\000\217\000\000\000\217\000\000\000\000\000\000\000\000\000\000\000\000\000\217\000\217\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\217\000\217\000\000\000\217\000\000\000\000\000\000\000\217\000\217\000\138\000\217\000\000\000\000\000\000\000\217\000\000\000\197\000\197\000\197\000\197\000\197\000\000\000\197\000\197\000\146\000\000\000\162\000\197\000\197\000\000\000\197\000\000\000\000\000\197\000\178\000\197\000\197\000\197\000\197\000\000\000\000\000\197\000\197\000\000\000\197\000\000\000\000\000\000\000\000\000\000\000\000\000\197\000\197\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\197\000\197\000\000\000\186\000\000\000\000\000\000\000\197\000\197\000\213\000\197\000\000\000\000\000\000\000\197\000\000\000\213\000\213\000\213\000\213\000\213\000\000\000\213\000\213\000\146\000\000\000\162\000\213\000\213\000\000\000\213\000\000\000\000\000\213\000\213\000\213\000\213\000\213\000\213\000\000\000\000\000\213\000\213\000\000\000\213\000\000\000\000\000\000\000\000\000\000\000\000\000\213\000\213\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\213\000\213\000\000\000\213\000\000\000\000\000\000\000\213\000\213\000\209\000\213\000\000\000\000\000\000\000\213\000\000\000\209\000\209\000\209\000\209\000\209\000\000\000\209\000\209\000\146\000\000\000\162\000\209\000\209\000\000\000\209\000\000\000\000\000\209\000\209\000\209\000\209\000\209\000\209\000\000\000\000\000\209\000\209\000\000\000\209\000\000\000\000\000\000\000\000\000\000\000\000\000\209\000\209\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\209\000\209\000\000\000\209\000\000\000\000\000\000\000\209\000\209\000\138\000\209\000\000\000\000\000\000\000\209\000\000\000\201\000\201\000\201\000\201\000\201\000\000\000\201\000\201\000\146\000\000\000\162\000\201\000\201\000\000\000\201\000\000\000\000\000\201\000\178\000\201\000\201\000\201\000\201\000\000\000\000\000\201\000\201\000\000\000\201\000\000\000\000\000\000\000\000\000\000\000\000\000\201\000\201\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\201\000\201\000\000\000\186\000\000\000\000\000\000\000\201\000\201\000\138\000\201\000\000\000\000\000\000\000\201\000\000\000\237\000\237\000\237\000\237\000\237\000\000\000\237\000\237\000\146\000\000\000\162\000\170\000\237\000\000\000\237\000\000\000\000\000\237\000\178\000\194\000\237\000\237\000\237\000\000\000\000\000\237\000\237\000\000\000\237\000\000\000\000\000\000\000\000\000\000\000\000\000\237\000\237\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\237\000\237\000\000\000\186\000\000\000\000\000\000\000\237\000\237\000\138\000\237\000\000\000\000\000\000\000\237\000\000\000\233\000\233\000\233\000\233\000\233\000\000\000\233\000\233\000\146\000\000\000\162\000\170\000\233\000\000\000\233\000\000\000\000\000\233\000\178\000\194\000\233\000\233\000\233\000\000\000\000\000\233\000\233\000\000\000\233\000\000\000\000\000\000\000\000\000\000\000\000\000\233\000\233\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\233\000\233\000\000\000\186\000\000\000\000\000\000\000\233\000\233\000\138\000\233\000\000\000\000\000\000\000\233\000\000\000\225\000\225\000\225\000\225\000\225\000\000\000\225\000\225\000\146\000\000\000\162\000\170\000\225\000\000\000\225\000\000\000\000\000\225\000\178\000\194\000\225\000\225\000\225\000\000\000\000\000\225\000\225\000\000\000\225\000\000\000\000\000\000\000\000\000\000\000\000\000\225\000\225\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\225\000\225\000\000\000\186\000\000\000\000\000\000\000\225\000\225\000\138\000\225\000\000\000\000\000\000\000\225\000\000\000\154\000\202\000\210\001\001\001\001\000\000\001\001\001\001\000\146\000\000\000\162\000\170\000\218\000\000\001\001\000\000\000\000\001\001\000\178\000\194\000\234\001\001\001\001\000\000\000\000\001\002\001\001\000\000\001\001\000\000\000\000\000\000\000\000\000\000\000\000\001\n\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\001\001\000\000\000\186\000\000\000\000\000\000\001\001\001\001\000\138\000\242\000\000\000\000\000\000\000\250\000\000\000\154\000\202\000\210\001\005\001\005\000\000\001\005\001\005\000\146\000\000\000\162\000\170\000\218\000\000\001\005\000\000\000\000\001\005\000\178\000\194\001\005\001\005\001\005\000\000\000\000\001\005\001\005\000\000\001\005\000\000\000\000\000\000\000\000\000\000\000\000\001\005\001\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\005\001\005\000\000\000\186\000\000\000\000\000\000\001\005\001\005\000\138\000\242\000\000\000\000\000\000\000\250\000\000\000\229\000\229\000\229\000\229\000\229\000\000\000\229\000\229\000\146\000\000\000\162\000\170\000\229\000\000\000\229\000\000\000\000\000\229\000\178\000\194\000\229\000\229\000\229\000\000\000\000\000\229\000\229\000\000\000\229\000\000\000\000\000\000\000\000\000\000\000\000\000\229\000\229\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\229\000\229\000\000\000\186\000\000\000\000\000\000\000\229\000\229\000\138\000\229\000\000\000\000\000\000\000\229\000\000\000\221\000\221\000\221\000\221\000\221\000\000\000\221\000\221\000\146\000\000\000\162\000\170\000\221\000\000\000\221\000\000\000\000\000\221\000\178\000\194\000\221\000\221\000\221\000\000\000\000\000\221\000\221\000\000\000\221\000\000\000\000\000\000\000\000\000\000\000\000\000\221\000\221\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\221\000\221\000\000\000\186\000\000\000\000\000\000\000\221\000\221\000\138\000\221\000\000\000\000\000\000\000\221\000\000\000\154\000\202\000\210\001\r\001\r\000\000\001\r\001\r\000\146\000\000\000\162\000\170\000\218\000\000\001\r\000\000\000\000\001\r\000\178\000\194\001\r\001\r\001\r\000\000\000\000\001\r\001\r\000\000\001\r\000\000\000\000\000\000\000\000\000\000\000\000\001\r\001\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\r\001\r\000\000\000\186\000\000\000\000\000\000\001\r\001\r\000\138\000\242\000\000\000\000\000\000\000\250\000\000\000\154\000\202\000\210\001\t\001\t\000\000\001\t\001\t\000\146\000\000\000\162\000\170\000\218\000\000\001\t\000\000\000\000\001\t\000\178\000\194\001\t\001\t\001\t\000\000\000\000\001\t\001\t\000\000\001\t\000\000\000\000\000\000\000\000\000\000\000\000\001\t\001\t\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\t\001\t\000\000\000\186\000\000\000\000\000\000\001\t\001\t\000\138\000\242\000\000\000\000\000\000\000\250\000\000\000\154\000\202\000\210\001\017\001\017\000\000\001\017\001\017\000\146\000\000\000\162\000\170\000\218\000\000\001\017\000\000\000\000\001\017\000\178\000\194\001\017\001\017\001\017\000\000\000\000\001\017\001\017\000\000\001\017\000\000\000\000\000\000\000\000\000\000\000\000\001\017\001\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\017\001\017\000\000\000\186\000\000\000\000\000\000\001\017\001\017\000\138\000\242\000\000\000\000\000\000\000\250\000\000\000\154\000\202\000\210\000\249\000\249\000\000\000\249\000\249\000\146\000\000\000\162\000\170\000\218\000\000\000\249\000\000\000\000\000\226\000\178\000\194\000\234\000\249\000\249\000\000\000\000\001\002\000\249\000\000\000\249\000\000\000\000\000\000\000\000\000\000\000\000\001\n\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\"\000\249\000\000\000\186\000\000\000\000\000\000\000\249\000\249\000\138\000\242\000\000\000\000\000\000\000\250\000\000\000\154\000\202\000\210\000\253\000\253\000\000\000\253\000\253\000\146\000\000\000\162\000\170\000\218\000\000\000\253\000\000\000\000\000\253\000\178\000\194\000\234\000\253\000\253\000\000\000\000\001\002\000\253\000\000\000\253\000\000\000\000\000\000\000\000\000\000\000\000\001\n\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\253\000\253\000\000\000\186\000\000\000\000\000\000\000\253\000\253\000\138\000\242\000\000\000\000\000\000\000\250\000\000\000\154\000\202\000\210\000\245\000\245\000\000\000\245\000\245\000\146\000\000\000\162\000\170\000\218\000\000\000\245\000\000\000\000\000\226\000\178\000\194\000\234\000\245\000\245\000\000\000\000\001\002\000\245\000\000\000\245\000\000\000\000\000\000\000\000\000\000\000\000\001\n\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\"\000\245\000\000\000\186\000\000\000\000\000\000\000\245\000\245\001\021\000\242\000\000\000\000\000\000\000\250\000\000\001\021\001\021\001\021\001\021\001\021\000\000\001\021\001\021\001\021\000\000\000\162\001\021\001\021\000\000\001\021\000\000\000\000\001\021\001\021\001\021\001\021\001\021\001\021\000\000\000\000\001\021\001\021\000\000\001\021\000\000\000\000\000\000\000\000\000\000\000\000\001\021\001\021\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\021\001\021\000\000\001\021\000\000\000\000\000\000\001\021\001\021\000\138\001\021\000\000\000\000\000\000\001\021\000\000\000\154\000\202\000\210\001}\001v\000\000\002r\001}\000\146\000\000\000\162\000\170\000\218\000\000\002\194\000\000\000\000\000\226\000\178\000\194\000\234\001B\001\026\000\000\000\000\001\002\002j\000\000\001*\000\000\000\000\000\000\000\000\000\000\000\000\001\n\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\"\001}\000\006\000\186\000\n\000\014\000\000\000\018\000\022\000\026\000\242\000\000\000\000\001\029\000\250\000\000\000u\001\029\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\030\000\000\000\000\000\"\000\000\000&\000\000\000*\000.\000\000\0002\0006\000\000\000:\000>\000B\000\000\000F\000\000\000\000\000\000\000\000\000J\000N\000R\000\000\000\000\000V\000\006\001\029\000\n\000\014\000\000\000\018\000\022\000\026\000\000\000\000\000\000\000Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\154\000\000\002\162\000\030\000\000\000\000\000\"\000\000\000&\000\000\000*\000.\000\000\0002\002\170\000\000\000:\000>\000B\000\000\000F\000\000\000\000\000\000\000\000\000J\000N\000R\000\138\002\178\000V\000\000\000\000\000\000\000\000\000\154\000\202\000\210\000\000\001=\000\000\001=\000Z\000\146\000\000\000\162\000\170\000\218\000\000\000\000\000\000\000\000\000\226\000\178\000\194\000\234\000\000\001\026\000\000\000\000\001\002\000\000\000\000\001*\000\000\000\000\000\000\000\000\000\000\000\000\001\n\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\"\001\147\000\000\000\186\000\000\000\000\000\000\001V\000\138\000\000\000\242\000\000\000\000\000\000\000\250\000\154\000\202\000\210\001!\001\218\000\000\000\000\001!\000\146\000\000\000\162\000\170\000\218\000\000\000\000\000\000\000\000\000\226\000\178\000\194\000\234\000\000\001\026\000\000\000\138\001\002\000\000\000\000\001*\000\000\000\000\000\154\000\202\000\210\0001\001\n\001\018\000\000\0001\000\146\000\000\000\162\000\170\000\218\001\"\001!\000\000\000\186\000\226\000\178\000\194\000\234\0012\001\026\000\242\001\193\001\002\000\000\000\250\001*\000\000\000\000\001\193\001\193\001\193\000\000\001\n\001\018\000\000\001\193\001\193\000\000\001\193\001\193\001\193\001\"\0001\000\000\000\186\001\193\001\193\001\193\001\193\000\000\001\193\000\242\000\000\001\193\001\193\000\250\001\193\000\000\000\000\000\000\000\000\000\000\000\000\001\193\001\193\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\193\000\000\000\000\001\193\000\000\000a\000\000\000\000\000\138\000\000\001\193\000\000\000\000\000\000\001\193\000\154\000\202\000\210\000=\000\000\000\000\000\000\000=\000\146\000\000\000\162\000\170\000\218\000\000\000\000\000\000\000\000\000\226\000\178\000\194\000\234\000\000\001\026\000\000\000\138\001\002\000\000\000\000\001*\000\000\000\000\000\154\000\202\000\210\0009\001\n\001\018\000\000\0009\000\146\000\000\000\162\000\170\000\218\001\"\000=\000\000\000\186\000\226\000\178\000\194\000\234\000\000\001\026\000\242\000\138\001\002\000\000\000\250\001*\000\000\000\000\000\154\000\202\000\210\001\141\001\n\001\018\000\000\001\141\000\146\000\000\000\162\000\170\000\218\001\"\0009\000\000\000\186\000\226\000\178\000\194\000\234\000\000\001\026\000\242\000\138\001\002\000\000\000\250\001*\000\000\000\000\000\154\000\202\000\210\001\145\001\n\001\018\000\000\001\145\000\146\000\000\000\162\000\170\000\218\001\"\001\141\000\000\000\186\000\226\000\178\000\194\000\234\000\000\001\026\000\242\000\138\001\002\000\000\000\250\001*\000\000\000\000\000\154\000\202\000\210\001\149\001\n\001\018\000\000\001\149\000\146\000\000\000\162\000\170\000\218\001\"\001\145\000\000\000\186\000\226\000\178\000\194\000\234\000\000\001\026\000\242\000\138\001\002\000\000\000\250\001*\000\000\000\000\000\154\000\202\000\210\001\157\001\n\001\018\000\000\001\157\000\146\000\000\000\162\000\170\000\218\001\"\001\149\000\000\000\186\000\226\000\178\000\194\000\234\000\000\001\026\000\242\000\000\001\002\000\000\000\250\001*\000\000\000\000\000\000\000\000\000\000\000\000\001\n\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\"\001\157\000\000\000\186\000\000\000\000\000\006\000\000\000\n\000\014\000\242\000\018\000\022\000\026\000\250\000\000\000\000\000\000\000u\000\000\000\000\002\174\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\030\000\000\000\000\000\"\000\000\000&\000\000\000*\000.\000\000\0002\0006\000\000\000:\000>\000B\000\000\000F\000\000\000\000\000\000\000\000\000J\000N\000R\000\000\000\138\000V\000\000\000\000\000\000\000\000\000\000\000\154\000\202\000\210\000\000\000\000\000\000\000Z\001:\000\146\000\000\000\162\000\170\000\218\000\000\000\000\000\000\000\000\000\226\000\178\000\194\000\234\000\000\001\026\000\000\000\000\001\002\002j\000\000\001*\000\000\000\000\000\000\000\000\000\000\000\000\001\n\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\"\000\000\000\000\000\186\000\000\000\000\000\000\000\000\000\000\000\000\000\242\000\000\000\000\000\000\000\250"))
  
  and lhs =
    (8, "\003\002\001\000('&%$#\"!    \031\031\031\031\031\030\029\028\027\026\025\025\024\023\023\022\022\021\021\020\020\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\019\018\018\017\017\016\015\015\015\014\014\r\r\012\012\011\011\n\n\n\n\n\n\t\b\007\007\007\007\007\007\007\007\007\007\006\005\005\005\005\005\005\004")
  
  and goto =
    ((16, "\0004\000~\000\248\000\000\001\148\001\162\000\000\000\000\001\170\001\204\001\218\001\238\001F\001\252\002\004\002&\000\000\000\000\0024\002H\000\000\002V\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002^\000\000\002\128\000\000\002\142\000\000\002\162\000\000\002\176\000\000\002\184\000\000\002\218\000\000\002\232\000\000\002\252\000\000\003\n\000\000\003\018\000\000\0034\000\000\003B\000\000\003V\000\000\003d\000\000\003l\000\000\003\142\000\000\003\156\000\000\003\176\000\000\003\190\000\000\003\198\000\000\003\232\000\000\000\000\000+\001\\\000\000\000\000\000\000\000\000\001r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000#\000&\000\000\000*\000\017\000\000\000\000\000\000\000\000\000\007\000\000\000\030\000\t\0006\003\246\000\000\000\000\000\"\000\000\000<\000\000\000\000\000H\000\000\000@\000\000\0002\000\000\000\024\000\000\000N\000\000\000\000\000\000\000\000\000\174\000\000\000\000\004\n\000\000\000B\000f\000X\000\000\000Z\000\000\000\000\001 \004\024\000\000\004 \000|\004B\000\000\000\000\000\000\004P\000\000\000\000\000\000\000\000\000\000\000\000\004d\004r\000\000\004z\000\000\001\252\000\000\000x\000d\000\000\000.\004\156\000\000\000\000\000\000\000\132\000\000\004\170\000\000\000\000\000\000\000\000\000\000\000\140\000\000\000\000\000\000\000\000\000\132\000\000\000\000\000\000\000\000\000\017\000\000\000\000\000\000\000\000\000\000\000J\000\000\000\000\000\214\000\000\000\000\000\000"), (8, "\024\025\026\161\200l\188\191\201\129q\163\196\203m\027\192X\198o\135\204\164\165o\131\207\181\185\136\024\025\026\029\129\186\187\024\025\026\161\025~\188\191\027j\179\163\206\130r\027\192\195xyd{\164\165\180f\029\194\185\204\024\025\026\029\128\186\187\024\025\026\161\134\145\188\190\027\146\148\163\158\174\175\027\182\024\025\026c\000\164\165\000\000\029\181\185\000\000\139\027\029\000\186\187\024\025\026\161\000\000\209\140\000\000\000\163\000\029\000\027\000\024\025\026\000\000\164\165\000\000\000\181\185\211\000\000\027\029\000\186\187\024\025\026\161\000\000\162b\000\000\000\163\000\029\000\027\000\000\000\024\025\026\164\165\000\000\000\181\185R\024\025\026\029\027\186\187\000Y\000R\024\025\026\000\027U\000\000S\000W\029\000\000\000\027U\024\025\026\000\000\029\000\024\025\026U\024\025\026\000\027\029\000\000\000\000\000\027\000\000\000\027a\024\025\026\000\000\029`\024\025\026_\000\029\000\000\027\029\024\025\026\000\000\027\000\024\025\026]\024\025\026\000\027\029\\\000\000\000\000\027\029\000\000\027[\024\025\026\000\000\029\"\024\025\026!\000\029\000\000\027\029\024\025\026\000\000\027\000\024\025\026 \024\025\026\000\027\029\031\000\000\000\000\027\029\000\000\027\030\024\025\026\000\000\029\028\024\025\026$\000\029\000\000\027\029\024\025\026\000\000\027\000\024\025\026&\024\025\026\000\027\029(\000\000\000\000\027\029\000\000\027*\024\025\026\000\000\029,\024\025\026.\000\029\000\000\027\029\024\025\026\000\000\027\000\024\025\0260\024\025\026\000\027\0292\000\000\000\000\027\029\000\000\0274\024\025\026\000\000\0296\024\025\0268\000\029\000\000\027\029\024\025\026\000\000\027\000\024\025\026:\024\025\026\000\027\029<\000\000\000\000\027\029\000\000\027>\024\025\026\000\000\029@\024\025\026B\000\029\000\000\027\029\024\025\026\000\000\027\000\024\025\026D\024\025\026\000\027\029F\000\000\000\000\027\029\000\000\027H\024\025\026\000\000\029J\024\025\026L\000\029\000\000\027\029\024\025\026\000\000\027\000\024\025\026N\024\025\026\000\027\029v\000\000\000\000\027\029\000\000\027\142\024\025\026\000\000\029\152\024\025\026\154\000\029\000\000\027\029\024\025\026\000\000\027\000\024\025\026\156\024\025\026\000\027\029\160\000\000\000\000\027\029\000\000\027\176\024\025\026\000\000\029\168\024\025\026\170\000\029\000\000\027\029\000\000\000\000\000\027\000\000\000\000\178\000\000\000\000\000\029\184\000\000\000\000\000\029"))
  
  and semantic_action =
    [|
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let s : (EslSyntax.Stmt.t) = Obj.magic s in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_s_ in
        let _v =
          let _endpos = _endpos_s_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 120 "src/semantics/core/parser/parser.mly"
    ( Stmt.Debug s @> at _sloc )
# 456 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = xs;
            MenhirLib.EngineTypes.startp = _startpos_xs_;
            MenhirLib.EngineTypes.endp = _endpos_xs_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let xs : (EslSyntax.Stmt.t list) = Obj.magic xs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v =
          let ss = 
# 241 "<standard.mly>"
    ( xs )
# 497 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos__3_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 156 "src/semantics/core/parser/parser.mly"
    ( Stmt.Block ss @> at _sloc )
# 505 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = xs;
            MenhirLib.EngineTypes.startp = _startpos_xs_;
            MenhirLib.EngineTypes.endp = _endpos_xs_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let xs : (EslSyntax.Expr.t list) = Obj.magic xs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (EslSyntax.Expr.t list) = 
# 241 "<standard.mly>"
    ( xs )
# 545 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = es;
          MenhirLib.EngineTypes.startp = _startpos_es_;
          MenhirLib.EngineTypes.endp = _endpos_es_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = fe;
                MenhirLib.EngineTypes.startp = _startpos_fe_;
                MenhirLib.EngineTypes.endp = _endpos_fe_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let es : (EslSyntax.Expr.t list) = Obj.magic es in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let fe : (EslSyntax.Expr.t) = Obj.magic fe in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_es_ in
        let _v =
          let _endpos = _endpos_es_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 207 "src/semantics/core/parser/parser.mly"
    ( Expr.Curry (fe, es) @> at _sloc )
# 602 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = expr_target;
            MenhirLib.EngineTypes.startp = _startpos_expr_target_;
            MenhirLib.EngineTypes.endp = _endpos_expr_target_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let expr_target : (EslSyntax.Expr.t) = Obj.magic expr_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_expr_target_ in
        let _endpos = _endpos__2_ in
        let _v : (EslSyntax.Expr.t) = expr_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = func_target;
            MenhirLib.EngineTypes.startp = _startpos_func_target_;
            MenhirLib.EngineTypes.endp = _endpos_func_target_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let func_target : (EslSyntax.Func.t) = Obj.magic func_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_func_target_ in
        let _endpos = _endpos__2_ in
        let _v : (EslSyntax.Func.t) = func_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = prog_target;
            MenhirLib.EngineTypes.startp = _startpos_prog_target_;
            MenhirLib.EngineTypes.endp = _endpos_prog_target_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let prog_target : (EslSyntax.Prog.t) = Obj.magic prog_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_prog_target_ in
        let _endpos = _endpos__2_ in
        let _v : (EslSyntax.Prog.t) = prog_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = stmt_target;
            MenhirLib.EngineTypes.startp = _startpos_stmt_target_;
            MenhirLib.EngineTypes.endp = _endpos_stmt_target_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let stmt_target : (EslSyntax.Stmt.t) = Obj.magic stmt_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_stmt_target_ in
        let _endpos = _endpos__2_ in
        let _v : (EslSyntax.Stmt.t) = stmt_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 124 "src/semantics/core/parser/parser.mly"
    ( Stmt.Print e @> at _sloc )
# 751 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t option) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 126 "src/semantics/core/parser/parser.mly"
    ( Stmt.Return (Parsing_helper.Expr.parse_return_expr e) @> at _sloc )
# 788 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 128 "src/semantics/core/parser/parser.mly"
    ( Stmt.Assert e @> at _sloc )
# 825 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 130 "src/semantics/core/parser/parser.mly"
    ( Stmt.Fail e @> at _sloc )
# 862 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = expr_target;
            MenhirLib.EngineTypes.startp = _startpos_expr_target_;
            MenhirLib.EngineTypes.endp = _endpos_expr_target_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let expr_target : (EslSyntax.Expr.t) = Obj.magic expr_target in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (EslSyntax.Expr.t) = expr_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = val_expr_target;
          MenhirLib.EngineTypes.startp = _startpos_val_expr_target_;
          MenhirLib.EngineTypes.endp = _endpos_val_expr_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let val_expr_target : (EslSyntax.Expr.t) = Obj.magic val_expr_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_val_expr_target_ in
        let _endpos = _endpos_val_expr_target_ in
        let _v : (EslSyntax.Expr.t) = val_expr_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = var_expr_target;
          MenhirLib.EngineTypes.startp = _startpos_var_expr_target_;
          MenhirLib.EngineTypes.endp = _endpos_var_expr_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let var_expr_target : (EslSyntax.Expr.t) = Obj.magic var_expr_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_var_expr_target_ in
        let _endpos = _endpos_var_expr_target_ in
        let _v : (EslSyntax.Expr.t) = var_expr_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = op_expr_target;
          MenhirLib.EngineTypes.startp = _startpos_op_expr_target_;
          MenhirLib.EngineTypes.endp = _endpos_op_expr_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let op_expr_target : (EslSyntax.Expr.t) = Obj.magic op_expr_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_op_expr_target_ in
        let _endpos = _endpos_op_expr_target_ in
        let _v : (EslSyntax.Expr.t) = op_expr_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = curry_expr_target;
          MenhirLib.EngineTypes.startp = _startpos_curry_expr_target_;
          MenhirLib.EngineTypes.endp = _endpos_curry_expr_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let curry_expr_target : (EslSyntax.Expr.t) = Obj.magic curry_expr_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_curry_expr_target_ in
        let _endpos = _endpos_curry_expr_target_ in
        let _v : (EslSyntax.Expr.t) = curry_expr_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = xs;
            MenhirLib.EngineTypes.startp = _startpos_xs_;
            MenhirLib.EngineTypes.endp = _endpos_xs_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let xs : (EslSyntax.Id.t list) = Obj.magic xs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v =
          let _2 = 
# 241 "<standard.mly>"
    ( xs )
# 1022 "src/semantics/core/parser/parser.ml"
           in
          let _2_1 = _2 in
          (
# 211 "src/semantics/core/parser/parser.mly"
                                                                                  Parsing_helper.Func.parse_params  
# 1028 "src/semantics/core/parser/parser.ml"
           _2_1 : (EslSyntax.Id.t list))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = pxs;
            MenhirLib.EngineTypes.startp = _startpos_pxs_;
            MenhirLib.EngineTypes.endp = _endpos_pxs_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = fn;
              MenhirLib.EngineTypes.startp = _startpos_fn_;
              MenhirLib.EngineTypes.endp = _endpos_fn_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let s : (EslSyntax.Stmt.t) = Obj.magic s in
        let pxs : (EslSyntax.Id.t list) = Obj.magic pxs in
        let fn : (EslSyntax.Id.t) = Obj.magic fn in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_s_ in
        let _v =
          let _endpos = _endpos_s_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 106 "src/semantics/core/parser/parser.mly"
    ( Func.create fn pxs s @> at _sloc )
# 1079 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Func.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = expr_target;
            MenhirLib.EngineTypes.startp = _startpos_expr_target_;
            MenhirLib.EngineTypes.endp = _endpos_expr_target_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let expr_target : (EslSyntax.Expr.t) = Obj.magic expr_target in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (EslSyntax.Expr.t) = expr_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (
# 18 "src/semantics/core/parser/parser.mly"
       (string)
# 1136 "src/semantics/core/parser/parser.ml"
        ) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v =
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 219 "src/semantics/core/parser/parser.mly"
                                      ( (x @> at _sloc) )
# 1148 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Id.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = e;
            MenhirLib.EngineTypes.startp = _startpos_e_;
            MenhirLib.EngineTypes.endp = _endpos_e_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let s : (EslSyntax.Stmt.t) = Obj.magic s in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_s_ in
        let _v =
          let _endpos = _endpos_s_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 168 "src/semantics/core/parser/parser.mly"
    ( Stmt.While (e, s) @> at _sloc )
# 1192 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((EslSyntax.Expr.t * EslSyntax.Stmt.t) list) = 
# 216 "<standard.mly>"
    ( [] )
# 1211 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x;
            MenhirLib.EngineTypes.startp = _startpos_x_;
            MenhirLib.EngineTypes.endp = _endpos_x_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let xs : ((EslSyntax.Expr.t * EslSyntax.Stmt.t) list) = Obj.magic xs in
        let x : (EslSyntax.Expr.t * EslSyntax.Stmt.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : ((EslSyntax.Expr.t * EslSyntax.Stmt.t) list) = 
# 219 "<standard.mly>"
    ( x :: xs )
# 1243 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = expr_target;
            MenhirLib.EngineTypes.startp = _startpos_expr_target_;
            MenhirLib.EngineTypes.endp = _endpos_expr_target_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let expr_target : (EslSyntax.Expr.t) = Obj.magic expr_target in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (EslSyntax.Expr.t) = expr_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (EslSyntax.Expr.t list) = 
# 145 "<standard.mly>"
    ( [] )
# 1296 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Expr.t list) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Expr.t list) = 
# 148 "<standard.mly>"
    ( x )
# 1321 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (EslSyntax.Id.t list) = 
# 145 "<standard.mly>"
    ( [] )
# 1339 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Id.t list) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Id.t list) = 
# 148 "<standard.mly>"
    ( x )
# 1364 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (EslSyntax.Func.t list) = 
# 145 "<standard.mly>"
    ( [] )
# 1382 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Func.t list) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Func.t list) = 
# 148 "<standard.mly>"
    ( x )
# 1407 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (EslSyntax.Stmt.t list) = 
# 145 "<standard.mly>"
    ( [] )
# 1425 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Stmt.t list) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Stmt.t list) = 
# 148 "<standard.mly>"
    ( x )
# 1450 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 232 "src/semantics/core/parser/parser.mly"
                            ( Operator.Neg )
# 1483 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1492 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 233 "src/semantics/core/parser/parser.mly"
                            ( Operator.BitwiseNot )
# 1526 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1535 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 234 "src/semantics/core/parser/parser.mly"
                            ( Operator.LogicalNot )
# 1569 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1578 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 235 "src/semantics/core/parser/parser.mly"
                            ( Operator.ListHead )
# 1612 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1621 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 236 "src/semantics/core/parser/parser.mly"
                            ( Operator.ListTail )
# 1655 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1664 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 237 "src/semantics/core/parser/parser.mly"
                            ( Operator.Typeof )
# 1698 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1707 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 238 "src/semantics/core/parser/parser.mly"
                            ( Operator.IntToFloat )
# 1741 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1750 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 239 "src/semantics/core/parser/parser.mly"
                            ( Operator.IntToString )
# 1784 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1793 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 240 "src/semantics/core/parser/parser.mly"
                            ( Operator.FloatToInt )
# 1827 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1836 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 241 "src/semantics/core/parser/parser.mly"
                            ( Operator.FloatToString )
# 1870 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1879 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 242 "src/semantics/core/parser/parser.mly"
                            ( Operator.StringToInt )
# 1913 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1922 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v =
          let op = 
# 243 "src/semantics/core/parser/parser.mly"
                            ( Operator.StringToFloat )
# 1956 "src/semantics/core/parser/parser.ml"
           in
          let _startpos_op_ = _startpos__1_ in
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_op_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 197 "src/semantics/core/parser/parser.mly"
    ( Expr.UnOpt (op, e) @> at _sloc )
# 1965 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 246 "src/semantics/core/parser/parser.mly"
                            ( Operator.Plus )
# 2006 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2014 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 247 "src/semantics/core/parser/parser.mly"
                            ( Operator.Minus )
# 2055 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2063 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 248 "src/semantics/core/parser/parser.mly"
                            ( Operator.Times )
# 2104 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2112 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 249 "src/semantics/core/parser/parser.mly"
                            ( Operator.Div )
# 2153 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2161 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 250 "src/semantics/core/parser/parser.mly"
                            ( Operator.Modulo )
# 2202 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2210 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 251 "src/semantics/core/parser/parser.mly"
                            ( Operator.Pow )
# 2251 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2259 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 252 "src/semantics/core/parser/parser.mly"
                            ( Operator.BitwiseAnd )
# 2300 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2308 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 253 "src/semantics/core/parser/parser.mly"
                            ( Operator.BitwiseOr )
# 2349 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2357 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 254 "src/semantics/core/parser/parser.mly"
                            ( Operator.BitwiseXor )
# 2398 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2406 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 255 "src/semantics/core/parser/parser.mly"
                            ( Operator.ShiftLeft )
# 2447 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2455 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 256 "src/semantics/core/parser/parser.mly"
                            ( Operator.ShiftRight )
# 2496 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2504 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 257 "src/semantics/core/parser/parser.mly"
                            ( Operator.ShiftRightLogical )
# 2545 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2553 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 258 "src/semantics/core/parser/parser.mly"
                            ( Operator.LogicalAnd )
# 2594 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2602 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 259 "src/semantics/core/parser/parser.mly"
                            ( Operator.LogicalOr )
# 2643 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2651 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 260 "src/semantics/core/parser/parser.mly"
                            ( Operator.Eq )
# 2692 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2700 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 261 "src/semantics/core/parser/parser.mly"
                            ( Operator.Ne )
# 2741 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2749 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 262 "src/semantics/core/parser/parser.mly"
                            ( Operator.Lt )
# 2790 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2798 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 263 "src/semantics/core/parser/parser.mly"
                            ( Operator.Gt )
# 2839 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2847 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 264 "src/semantics/core/parser/parser.mly"
                            ( Operator.Le )
# 2888 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2896 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _1 : unit = Obj.magic _1 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let op = 
# 265 "src/semantics/core/parser/parser.mly"
                            ( Operator.Ge )
# 2937 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 199 "src/semantics/core/parser/parser.mly"
    ( Expr.BinOpt (op, e1, e2) @> at _sloc )
# 2945 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e3;
          MenhirLib.EngineTypes.startp = _startpos_e3_;
          MenhirLib.EngineTypes.endp = _endpos_e3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = e2;
              MenhirLib.EngineTypes.startp = _startpos_e2_;
              MenhirLib.EngineTypes.endp = _endpos_e2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = e1;
                  MenhirLib.EngineTypes.startp = _startpos_e1_;
                  MenhirLib.EngineTypes.endp = _endpos_e1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let e3 : (EslSyntax.Expr.t) = Obj.magic e3 in
        let _4 : unit = Obj.magic _4 in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _2 : unit = Obj.magic _2 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e1_ in
        let _endpos = _endpos_e3_ in
        let _v =
          let _endpos = _endpos_e3_ in
          let _symbolstartpos = _startpos_e1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 201 "src/semantics/core/parser/parser.mly"
    ( Expr.TriOpt (Conditional, e1, e2, e3) @> at _sloc )
# 3003 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = xs;
            MenhirLib.EngineTypes.startp = _startpos_xs_;
            MenhirLib.EngineTypes.endp = _endpos_xs_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let xs : (EslSyntax.Expr.t list) = Obj.magic xs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v =
          let es = 
# 241 "<standard.mly>"
    ( xs )
# 3044 "src/semantics/core/parser/parser.ml"
           in
          let _endpos = _endpos__3_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 203 "src/semantics/core/parser/parser.mly"
    ( Expr.NOpt (ListExpr, es) @> at _sloc )
# 3052 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (EslSyntax.Expr.t option) = 
# 111 "<standard.mly>"
    ( None )
# 3071 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Expr.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Expr.t option) = 
# 114 "<standard.mly>"
    ( Some x )
# 3096 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (EslSyntax.Stmt.t option) = 
# 111 "<standard.mly>"
    ( None )
# 3114 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Stmt.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Stmt.t option) = 
# 114 "<standard.mly>"
    ( Some x )
# 3139 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let xs : (EslSyntax.Func.t list) = Obj.magic xs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_xs_ in
        let _endpos = _endpos_xs_ in
        let _v =
          let _1 = 
# 241 "<standard.mly>"
    ( xs )
# 3165 "src/semantics/core/parser/parser.ml"
           in
          let _1_1 = _1 in
          (
# 100 "src/semantics/core/parser/parser.mly"
      Prog.create  
# 3171 "src/semantics/core/parser/parser.ml"
           _1_1 : (EslSyntax.Prog.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = s1;
          MenhirLib.EngineTypes.startp = _startpos_s1_;
          MenhirLib.EngineTypes.endp = _endpos_s1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = e;
            MenhirLib.EngineTypes.startp = _startpos_e_;
            MenhirLib.EngineTypes.endp = _endpos_e_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let s1 : (EslSyntax.Stmt.t) = Obj.magic s1 in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_s1_ in
        let _v =
          let _endpos = _endpos_s1_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 160 "src/semantics/core/parser/parser.mly"
    ( Stmt.If (e, s1, None) @> at _sloc )
# 3215 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = s2;
          MenhirLib.EngineTypes.startp = _startpos_s2_;
          MenhirLib.EngineTypes.endp = _endpos_s2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = s1;
              MenhirLib.EngineTypes.startp = _startpos_s1_;
              MenhirLib.EngineTypes.endp = _endpos_s1_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = e;
                MenhirLib.EngineTypes.startp = _startpos_e_;
                MenhirLib.EngineTypes.endp = _endpos_e_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let s2 : (EslSyntax.Stmt.t) = Obj.magic s2 in
        let _4 : unit = Obj.magic _4 in
        let s1 : (EslSyntax.Stmt.t) = Obj.magic s1 in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_s2_ in
        let _v =
          let _endpos = _endpos_s2_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 162 "src/semantics/core/parser/parser.mly"
    ( Stmt.If (e, s1, Some s2) @> at _sloc )
# 3273 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = dflt;
            MenhirLib.EngineTypes.startp = _startpos_dflt_;
            MenhirLib.EngineTypes.endp = _endpos_dflt_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = css;
              MenhirLib.EngineTypes.startp = _startpos_css_;
              MenhirLib.EngineTypes.endp = _endpos_css_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _;
                  MenhirLib.EngineTypes.semv = e;
                  MenhirLib.EngineTypes.startp = _startpos_e_;
                  MenhirLib.EngineTypes.endp = _endpos_e_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let dflt : (EslSyntax.Stmt.t option) = Obj.magic dflt in
        let css : ((EslSyntax.Expr.t * EslSyntax.Stmt.t) list) = Obj.magic css in
        let _3 : unit = Obj.magic _3 in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v =
          let _endpos = _endpos__6_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 164 "src/semantics/core/parser/parser.mly"
    ( Stmt.Switch (e, (Parsing_helper.Stmt.parse_switch_cases css), dflt) @> at _sloc )
# 3338 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Expr.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Expr.t list) = 
# 250 "<standard.mly>"
    ( [ x ] )
# 3364 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (EslSyntax.Expr.t list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Expr.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (EslSyntax.Expr.t list) = 
# 253 "<standard.mly>"
    ( x :: xs )
# 3403 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Id.t list) = 
# 250 "<standard.mly>"
    ( [ x ] )
# 3428 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (EslSyntax.Id.t list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (EslSyntax.Id.t list) = 
# 253 "<standard.mly>"
    ( x :: xs )
# 3467 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Func.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Func.t list) = 
# 250 "<standard.mly>"
    ( [ x ] )
# 3492 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (EslSyntax.Func.t list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Func.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (EslSyntax.Func.t list) = 
# 253 "<standard.mly>"
    ( x :: xs )
# 3531 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (EslSyntax.Stmt.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (EslSyntax.Stmt.t list) = 
# 250 "<standard.mly>"
    ( [ x ] )
# 3556 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (EslSyntax.Stmt.t list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Stmt.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (EslSyntax.Stmt.t list) = 
# 253 "<standard.mly>"
    ( x :: xs )
# 3595 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = aux_stmt_target;
          MenhirLib.EngineTypes.startp = _startpos_aux_stmt_target_;
          MenhirLib.EngineTypes.endp = _endpos_aux_stmt_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let aux_stmt_target : (EslSyntax.Stmt.t) = Obj.magic aux_stmt_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_aux_stmt_target_ in
        let _endpos = _endpos_aux_stmt_target_ in
        let _v : (EslSyntax.Stmt.t) = aux_stmt_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = exec_stmt_target;
          MenhirLib.EngineTypes.startp = _startpos_exec_stmt_target_;
          MenhirLib.EngineTypes.endp = _endpos_exec_stmt_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let exec_stmt_target : (EslSyntax.Stmt.t) = Obj.magic exec_stmt_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_exec_stmt_target_ in
        let _endpos = _endpos_exec_stmt_target_ in
        let _v : (EslSyntax.Stmt.t) = exec_stmt_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = update_stmt_target;
          MenhirLib.EngineTypes.startp = _startpos_update_stmt_target_;
          MenhirLib.EngineTypes.endp = _endpos_update_stmt_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let update_stmt_target : (EslSyntax.Stmt.t) = Obj.magic update_stmt_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_update_stmt_target_ in
        let _endpos = _endpos_update_stmt_target_ in
        let _v : (EslSyntax.Stmt.t) = update_stmt_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = block_stmt_target;
          MenhirLib.EngineTypes.startp = _startpos_block_stmt_target_;
          MenhirLib.EngineTypes.endp = _endpos_block_stmt_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let block_stmt_target : (EslSyntax.Stmt.t) = Obj.magic block_stmt_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_block_stmt_target_ in
        let _endpos = _endpos_block_stmt_target_ in
        let _v : (EslSyntax.Stmt.t) = block_stmt_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = selection_stmt_target;
          MenhirLib.EngineTypes.startp = _startpos_selection_stmt_target_;
          MenhirLib.EngineTypes.endp = _endpos_selection_stmt_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let selection_stmt_target : (EslSyntax.Stmt.t) = Obj.magic selection_stmt_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_selection_stmt_target_ in
        let _endpos = _endpos_selection_stmt_target_ in
        let _v : (EslSyntax.Stmt.t) = selection_stmt_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = iteration_stmt_target;
          MenhirLib.EngineTypes.startp = _startpos_iteration_stmt_target_;
          MenhirLib.EngineTypes.endp = _endpos_iteration_stmt_target_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let iteration_stmt_target : (EslSyntax.Stmt.t) = Obj.magic iteration_stmt_target in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_iteration_stmt_target_ in
        let _endpos = _endpos_iteration_stmt_target_ in
        let _v : (EslSyntax.Stmt.t) = iteration_stmt_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = e;
              MenhirLib.EngineTypes.startp = _startpos_e_;
              MenhirLib.EngineTypes.endp = _endpos_e_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let s : (EslSyntax.Stmt.t) = Obj.magic s in
        let _3 : unit = Obj.magic _3 in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_s_ in
        let _v : (EslSyntax.Expr.t * EslSyntax.Stmt.t) = 
# 174 "src/semantics/core/parser/parser.mly"
                                                                                   ( (e, s) )
# 3767 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = block_stmt_target;
          MenhirLib.EngineTypes.startp = _startpos_block_stmt_target_;
          MenhirLib.EngineTypes.endp = _endpos_block_stmt_target_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let block_stmt_target : (EslSyntax.Stmt.t) = Obj.magic block_stmt_target in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_block_stmt_target_ in
        let _v : (EslSyntax.Stmt.t) = block_stmt_target in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_e_ in
        let _v =
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 134 "src/semantics/core/parser/parser.mly"
    ( Stmt.Assign (x, e) @> at _sloc )
# 3845 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = es;
          MenhirLib.EngineTypes.startp = _startpos_es_;
          MenhirLib.EngineTypes.endp = _endpos_es_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = fn;
            MenhirLib.EngineTypes.startp = _startpos_fn_;
            MenhirLib.EngineTypes.endp = _endpos_fn_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x;
                MenhirLib.EngineTypes.startp = _startpos_x_;
                MenhirLib.EngineTypes.endp = _endpos_x_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let es : (EslSyntax.Expr.t list) = Obj.magic es in
        let fn : (EslSyntax.Expr.t) = Obj.magic fn in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_es_ in
        let _v =
          let _endpos = _endpos_es_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 136 "src/semantics/core/parser/parser.mly"
    ( Stmt.AssignCall (x, fn, es) @> at _sloc )
# 3896 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = es;
          MenhirLib.EngineTypes.startp = _startpos_es_;
          MenhirLib.EngineTypes.endp = _endpos_es_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = fn;
            MenhirLib.EngineTypes.startp = _startpos_fn_;
            MenhirLib.EngineTypes.endp = _endpos_fn_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x;
                  MenhirLib.EngineTypes.startp = _startpos_x_;
                  MenhirLib.EngineTypes.endp = _endpos_x_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let es : (EslSyntax.Expr.t list) = Obj.magic es in
        let fn : (EslSyntax.Id.t) = Obj.magic fn in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_es_ in
        let _v =
          let _endpos = _endpos_es_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 138 "src/semantics/core/parser/parser.mly"
    ( Stmt.AssignECall (x, fn, es) @> at _sloc )
# 3954 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x;
                MenhirLib.EngineTypes.startp = _startpos_x_;
                MenhirLib.EngineTypes.endp = _endpos_x_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos__4_ in
        let _v =
          let _endpos = _endpos__4_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 140 "src/semantics/core/parser/parser.mly"
    ( Stmt.AssignNewObj x @> at _sloc )
# 4005 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x;
                MenhirLib.EngineTypes.startp = _startpos_x_;
                MenhirLib.EngineTypes.endp = _endpos_x_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_e_ in
        let _v =
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 142 "src/semantics/core/parser/parser.mly"
    ( Stmt.AssignObjToList (x, e) @> at _sloc )
# 4056 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x;
                MenhirLib.EngineTypes.startp = _startpos_x_;
                MenhirLib.EngineTypes.endp = _endpos_x_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_e_ in
        let _v =
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 144 "src/semantics/core/parser/parser.mly"
    ( Stmt.AssignObjFields (x, e) @> at _sloc )
# 4107 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e2;
          MenhirLib.EngineTypes.startp = _startpos_e2_;
          MenhirLib.EngineTypes.endp = _endpos_e2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = e1;
              MenhirLib.EngineTypes.startp = _startpos_e1_;
              MenhirLib.EngineTypes.endp = _endpos_e1_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x;
                  MenhirLib.EngineTypes.startp = _startpos_x_;
                  MenhirLib.EngineTypes.endp = _endpos_x_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let e2 : (EslSyntax.Expr.t) = Obj.magic e2 in
        let _4 : unit = Obj.magic _4 in
        let e1 : (EslSyntax.Expr.t) = Obj.magic e1 in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_e2_ in
        let _v =
          let _endpos = _endpos_e2_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 146 "src/semantics/core/parser/parser.mly"
    ( Stmt.AssignInObjCheck (x, e1, e2) @> at _sloc )
# 4165 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = fe;
          MenhirLib.EngineTypes.startp = _startpos_fe_;
          MenhirLib.EngineTypes.endp = _endpos_fe_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = oe;
            MenhirLib.EngineTypes.startp = _startpos_oe_;
            MenhirLib.EngineTypes.endp = _endpos_oe_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x;
                MenhirLib.EngineTypes.startp = _startpos_x_;
                MenhirLib.EngineTypes.endp = _endpos_x_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let fe : (EslSyntax.Expr.t) = Obj.magic fe in
        let oe : (EslSyntax.Expr.t) = Obj.magic oe in
        let _2 : unit = Obj.magic _2 in
        let x : (EslSyntax.Id.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_fe_ in
        let _v =
          let _endpos = _endpos_fe_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 148 "src/semantics/core/parser/parser.mly"
    ( Stmt.FieldLookup (x, oe, fe) @> at _sloc )
# 4216 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = fe;
              MenhirLib.EngineTypes.startp = _startpos_fe_;
              MenhirLib.EngineTypes.endp = _endpos_fe_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = oe;
                MenhirLib.EngineTypes.startp = _startpos_oe_;
                MenhirLib.EngineTypes.endp = _endpos_oe_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let e : (EslSyntax.Expr.t) = Obj.magic e in
        let _3 : unit = Obj.magic _3 in
        let fe : (EslSyntax.Expr.t) = Obj.magic fe in
        let oe : (EslSyntax.Expr.t) = Obj.magic oe in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_oe_ in
        let _endpos = _endpos_e_ in
        let _v =
          let _endpos = _endpos_e_ in
          let _symbolstartpos = _startpos_oe_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 150 "src/semantics/core/parser/parser.mly"
    ( Stmt.FieldAssign (oe, fe, e) @> at _sloc )
# 4267 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = fe;
          MenhirLib.EngineTypes.startp = _startpos_fe_;
          MenhirLib.EngineTypes.endp = _endpos_fe_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = oe;
            MenhirLib.EngineTypes.startp = _startpos_oe_;
            MenhirLib.EngineTypes.endp = _endpos_oe_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let fe : (EslSyntax.Expr.t) = Obj.magic fe in
        let oe : (EslSyntax.Expr.t) = Obj.magic oe in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_fe_ in
        let _v =
          let _endpos = _endpos_fe_ in
          let _symbolstartpos = _startpos__1_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 152 "src/semantics/core/parser/parser.mly"
    ( Stmt.FieldDelete (oe, fe) @> at _sloc )
# 4311 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Stmt.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = v;
          MenhirLib.EngineTypes.startp = _startpos_v_;
          MenhirLib.EngineTypes.endp = _endpos_v_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let v : (EslSyntax.Value.t) = Obj.magic v in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_v_ in
        let _endpos = _endpos_v_ in
        let _v =
          let _endpos = _endpos_v_ in
          let _symbolstartpos = _startpos_v_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 189 "src/semantics/core/parser/parser.mly"
    ( Expr.Val v @> at _sloc )
# 4341 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = i;
          MenhirLib.EngineTypes.startp = _startpos_i_;
          MenhirLib.EngineTypes.endp = _endpos_i_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let i : (
# 13 "src/semantics/core/parser/parser.mly"
       (int)
# 4363 "src/semantics/core/parser/parser.ml"
        ) = Obj.magic i in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_i_ in
        let _endpos = _endpos_i_ in
        let _v : (EslSyntax.Value.t) = 
# 222 "src/semantics/core/parser/parser.mly"
                              Value.Int  
# 4371 "src/semantics/core/parser/parser.ml"
         i in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = f;
          MenhirLib.EngineTypes.startp = _startpos_f_;
          MenhirLib.EngineTypes.endp = _endpos_f_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let f : (
# 14 "src/semantics/core/parser/parser.mly"
       (float)
# 4392 "src/semantics/core/parser/parser.ml"
        ) = Obj.magic f in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_f_ in
        let _endpos = _endpos_f_ in
        let _v : (EslSyntax.Value.t) = 
# 223 "src/semantics/core/parser/parser.mly"
                              Value.Real  
# 4400 "src/semantics/core/parser/parser.ml"
         f in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (
# 15 "src/semantics/core/parser/parser.mly"
       (string)
# 4421 "src/semantics/core/parser/parser.ml"
        ) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (EslSyntax.Value.t) = 
# 224 "src/semantics/core/parser/parser.mly"
                              Value.Str  
# 4429 "src/semantics/core/parser/parser.ml"
         s in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = b;
          MenhirLib.EngineTypes.startp = _startpos_b_;
          MenhirLib.EngineTypes.endp = _endpos_b_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let b : (
# 16 "src/semantics/core/parser/parser.mly"
       (bool)
# 4450 "src/semantics/core/parser/parser.ml"
        ) = Obj.magic b in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_b_ in
        let _endpos = _endpos_b_ in
        let _v : (EslSyntax.Value.t) = 
# 225 "src/semantics/core/parser/parser.mly"
                            ( if b then Value.True else Value.False )
# 4458 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (
# 17 "src/semantics/core/parser/parser.mly"
       (string)
# 4479 "src/semantics/core/parser/parser.ml"
        ) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (EslSyntax.Value.t) = 
# 226 "src/semantics/core/parser/parser.mly"
                            ( Value.App (`Op "symbol", [ Value.Str s ]) )
# 4487 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (EslSyntax.Value.t) = 
# 227 "src/semantics/core/parser/parser.mly"
                            ( Value.Nothing )
# 4512 "src/semantics/core/parser/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (
# 18 "src/semantics/core/parser/parser.mly"
       (string)
# 4533 "src/semantics/core/parser/parser.ml"
        ) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v =
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
          let _sloc = (_symbolstartpos, _endpos) in
          (
# 193 "src/semantics/core/parser/parser.mly"
    ( Expr.Var x @> at _sloc )
# 4545 "src/semantics/core/parser/parser.ml"
           : (EslSyntax.Expr.t))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
    |]
  
  and trace =
    None
  
end

module MenhirInterpreter = struct
  
  module ET = MenhirLib.TableInterpreter.MakeEngineTable (Tables)
  
  module TI = MenhirLib.Engine.Make (ET)
  
  include TI
  
end

let entry_stmt_target =
  fun lexer lexbuf : (EslSyntax.Stmt.t) ->
    Obj.magic (MenhirInterpreter.entry `Legacy 207 lexer lexbuf)

and entry_prog_target =
  fun lexer lexbuf : (EslSyntax.Prog.t) ->
    Obj.magic (MenhirInterpreter.entry `Legacy 198 lexer lexbuf)

and entry_func_target =
  fun lexer lexbuf : (EslSyntax.Func.t) ->
    Obj.magic (MenhirInterpreter.entry `Legacy 102 lexer lexbuf)

and entry_expr_target =
  fun lexer lexbuf : (EslSyntax.Expr.t) ->
    Obj.magic (MenhirInterpreter.entry `Legacy 0 lexer lexbuf)

module Incremental = struct
  
  let entry_stmt_target =
    fun initial_position : (EslSyntax.Stmt.t) MenhirInterpreter.checkpoint ->
      Obj.magic (MenhirInterpreter.start 207 initial_position)
  
  and entry_prog_target =
    fun initial_position : (EslSyntax.Prog.t) MenhirInterpreter.checkpoint ->
      Obj.magic (MenhirInterpreter.start 198 initial_position)
  
  and entry_func_target =
    fun initial_position : (EslSyntax.Func.t) MenhirInterpreter.checkpoint ->
      Obj.magic (MenhirInterpreter.start 102 initial_position)
  
  and entry_expr_target =
    fun initial_position : (EslSyntax.Expr.t) MenhirInterpreter.checkpoint ->
      Obj.magic (MenhirInterpreter.start 0 initial_position)
  
end
